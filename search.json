[{"title":"ERNIE-layout","url":"/2023/02/01/ERNIE-layout/","content":"<h1 id=\"ERNIE-Layout-Layout-Knowledge-Enhanced-Pre-training-for-Visually-rich-Document-Understanding\"><a href=\"#ERNIE-Layout-Layout-Knowledge-Enhanced-Pre-training-for-Visually-rich-Document-Understanding\" class=\"headerlink\" title=\"ERNIE-Layout: Layout Knowledge Enhanced Pre-training for Visually-rich Document Understanding\"></a>ERNIE-Layout: Layout Knowledge Enhanced Pre-training for Visually-rich Document Understanding</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>近年来，在富文档理解方面，已经见证了预训练技术的兴起和成功。然而，现有的大多数方法缺乏对以布局为中心的知识的系统挖掘和利用，导致性能不佳。论文提出了ERNIE-Layout，这是一种新颖的文档预训练解决方案，在整个工作流程中增强布局知识，以学习更好的表示方式，结合文本、布局和图像的特征。具体来说，我们首先在序列化阶段对输入序列进行重新排列，然后提出相关的预训练任务——阅读顺序预测，学习文档的正确阅读顺序。为了提高模型的布局意识，我们在多模态transformer中集成了空间感知解耦注意力，在预训练阶段集成了区域替换预测任务。实验结果表明ERNIE-Layout在各种下游任务上实现了卓越的性能，在关键信息提取、文档图像分类和文档问答数据集上达到新的技术水平。代码和模型可以在PaddleNLP上公开获取。</p>\n<p>VrDU：Visually-rich Document Understanding，NLU：Natural Language Understanding</p>\n<h2 id=\"问题及方案\"><a href=\"#问题及方案\" class=\"headerlink\" title=\"问题及方案\"></a>问题及方案</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>文档格式的多样性和复杂性对任务提出了新的挑战，理想的模型需要充分利用文本、布局甚至视觉信息，像人类一样充分理解视觉丰富的文档。</p>\n<p>VrDU的早期工作常采用单模态或浅多模态融合方法，这些方法是针对特定任务的，需要大量标注数据。最近预训练语言模型已经席卷了这个领域。LayoutLM、 LayoutLMv2、以及一些先进的文档预训练方法相继提出，并在各种VrDU任务中取得了巨大成功。与流行的单模态或视觉语言（Vision-Language）框架不同，<strong>文档理解模型的独特性在于如何利用布局知识。</strong>然而，现有的文档预训练解决方案通常会陷入将二维坐标作为一维位置扩展的陷阱，赋予模型布局感知能力。考虑到VrDU的特点，我们认为以布局为中心的知识应该从两个方面进行系统的挖掘和利用：</p>\n<p>（1）一方面，布局隐式地反映了文档的正确阅读顺序，而以往的方法都是将光学字符识别(OCR)的结果进行多路复用，大致按照从上到下、从左到右的方式排列token。对于具有复杂布局的文档(例如，表格、表单、多列模板)，这与人类的阅读习惯不一致，并导致下游任务的性能不佳。（2）另一方面，<strong>布局实际上是语言和语言之外的第三种形式</strong>，而目前的模型通常将布局作为一种特殊的位置特征，例如嵌入在输入层中的布局(LayoutLM)或注意层中的偏向项(LayoutLMv2)。布局与文本&#x2F;图像之间缺乏跨模态交互可能会限制模型学习布局在语义表达中的作用。</p>\n<h3 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h3><p>（1）首先，我们在序列化阶段采用现成的基于布局的文档解析器，为每个输入文档生成合适的阅读顺序，使模型接收到的输入序列比使用粗略的光栅扫描顺序更符合人类的阅读习惯。</p>\n<p>（2）然后，每个文本&#x2F;视觉token都配备了其位置嵌入和布局嵌入，并送到堆叠的多模态transformer层。受DeBERTa的解耦注意力启发， 我们提出了一种空间感知的解耦注意力机制，其中token之间的注意力权重是根据它们的隐藏状态和相对位置使用解耦矩阵计算的。最后，布局不仅作为输入token的二维位置属性，而且为语义相似度的计算提供了一个空间视角。</p>\n<h2 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h2><p>Ernie-layout 整体采用 Transformer Encoder 架构。</p>\n<p><img src=\"/2023/02/01/ERNIE-layout/image9.PNG\"></p>\n<h3 id=\"序列模块\"><a href=\"#序列模块\" class=\"headerlink\" title=\"序列模块\"></a>序列模块</h3><p>用Document-Parse作为先验知识告诉模型阅读的顺序（a layout-knowledge enhanced pre-training approach），将每个token加入阅读顺序的特征。PPL被广泛用于度量语言模型的性能。通过Document-Parser序列化的输入序列的PPL比光栅扫描顺序的PPL低。</p>\n<h3 id=\"输入表示\"><a href=\"#输入表示\" class=\"headerlink\" title=\"输入表示\"></a>输入表示</h3><p>ERNIE-Layout的输入序列包括文本部分和视觉部分，每个部分的表示是其模态特征和布局嵌入的组合。</p>\n<p><strong>文本嵌入</strong>（Text Embedding）。序列化模块之后的文档token用作文本序列。</p>\n<p>在BERT-Style模型的预处理之后，两个特殊标记[CLS]和[SEP]分别附加在文本序列的开头和结尾。最后，token序列T的文本嵌入表示为:<br>$$<br>T&#x3D;E_{tk}(T)+E_{1p}(T)+E_{tp}(T)<br>$$<br>这里$E_{tk}$、$E_{1p}$、$E_{tp}$分别是token embedding、1D position embedding以及token type  embedding。其中采用可学习的 position_embeddings 。position_ids通过 OCR 工具获得。采用 [Layout-Parser](<a href=\"https://github.com/Layout-Parser/\">https://github.com/Layout-Parser/</a> layout-parser) 对图片中的文本内容，根据阅读顺序进行排序，安排对应的 position_ids。</p>\n<p><strong>视觉嵌入（Visual Embedding）</strong>用 Faster-RCNN 当作encoder，图片先resize成224×224 ，然后池化得到7x7的feature,之后flaten成视觉序列，特征线性映射到text embedding 同样的维度。同样地，此外还键入position embedding和token type embedding。<br>$$<br>V&#x3D;F_{vs}(V)+E_{1p}(T)+E_{tp}(T)<br>$$</p>\n<p><strong>Layout Embedding</strong>。对于每个文本token，OCR工具提供包含边界框宽度和高度的2D坐标$(x_0,y_0,x_1,y_1,w,h)$，$(x_0,y_0)$表示左上角的坐标，$(x_1,y_1)$表示右下角的坐标。$w&#x3D;x_1-x_0$，$h&#x3D;y_1-y_0$，所有坐标规范化到$[0,1000]$，使用两个嵌入层表示横坐标和纵坐标。<br>$$<br>L&#x3D;E_{2x}(x_0,x_1,W)+E_{2y}(y_0,y_1,H)<br>$$<br>$E_{2x}$表示x轴嵌入层，$E_{2y}$表示y轴嵌入层。</p>\n<p>为了获得ERNIE-Layout最终的输入，我们将每个文本和视觉嵌入和它们对应的布局嵌入整合到一起。最终的序列长度是$N+HW$，文本和视觉与相关的Layout Embedding相加后concat。<br>$$<br>H&#x3D;[T+L;V+L]<br>$$</p>\n<h3 id=\"多模态Transformer\"><a href=\"#多模态Transformer\" class=\"headerlink\" title=\"多模态Transformer\"></a>多模态Transformer</h3><p>在最终的输入表示中，文本和视觉token被拼接在一起，Transformer的自注意机制支持它们的层感知跨模式交互。但是，作为一种独特的模态，在计算注意力权重时需要考虑布局特征，并明确考虑布局特征与内容(统称文字和图像)之间的紧密性。受DeBERTa 解耦注意力的启发，其中token之间的注意力权重是使用其内容上的解耦矩阵计算的。</p>\n<p>以1D位置为例，token $i$和token $j$的相对距离为$\\delta_{1p}$如下：<br>$$<br>y&#x3D; \\begin{cases}<br>0,\\quad &amp; i-j\\leq -k \\<br>2k-1,\\quad &amp;i-j\\ge k \\<br>i-j +k,\\quad &amp; others<br>\\end{cases}<br>$$<br>2D位置的相对距离同理。</p>\n<p>而后计算上下文-上下文，上下文-1D 位置信息, 上下文-2D 位置信息对应的 attention 权重：<br>$$<br>A_{ij}^{ct,ct}&#x3D;Q_i^{ct}K_l^{ct} \\<br>A_{ij}^{ct,1p}&#x3D;Q_i^{ct}K_{\\delta_{1p}(i,j)}^{1p} + {K_{j}^{ct}Q_{\\delta_{1p}(j,i)}^{1p}}^{\\top} \\<br>A_{ij}^{ct,2x}&#x3D;Q_i^{ct}K_{\\delta_{2x}(i,j)}^{2x} + {K_{j}^{ct}Q_{\\delta_{2x}(j,i)}^{2x}}^{\\top} \\<br>A_{ij}^{ct,2y}&#x3D;Q_i^{ct}K_{\\delta_{2y}(i,j)}^{2y} + {K_{j}^{ct}Q_{\\delta_{2y}(j,i)}^{2y}}^{\\top} \\<br>$$<br>最后，将所有这些注意得分进行汇总，得到注意矩阵$\\hat A $。通过缩放和归一化操作，空间感知解耦注意力的输出为：<br>$$<br>\\hat A_{ij}&#x3D;A_{ij}^{ct,ct}+A_{ij}^{ct,1p}+A_{ij}^{ct,2x}+A_{ij}^{ct,2y} \\<br>H_{out}&#x3D;softmax (\\frac{\\hat A}{\\sqrt 3d})<br>$$</p>\n<p><strong>issue 可以确认，paddlenlp 开源的 ernie-layoutx 为论文的降级版，其中的注意力模块、输入embedding模块等均与论文描述的不同。</strong></p>\n<blockquote>\n<p>ernie-layout代码中的实现:<a href=\"https://github.com/PaddlePaddle/PaddleNLP/blob/develop/paddlenlp/transformers/ernie_layout/modeling.py#L315\">https://github.com/PaddlePaddle/PaddleNLP/blob/develop/paddlenlp/transformers/ernie_layout/modeling.py#L315</a><br>这个attention和layoutlmv2一样的吧？</p>\n<p>考虑到商用，目前为降级开源，当前开出版本仍旧好于LayoutXLM，后续会适当的时候对外开源spatial-aware disentangled attention版本，如商业有需求请联系<a href=\"https://ai.baidu.com/tech/nlp/Textanalysis\">https://ai.baidu.com/tech/nlp/Textanalysis</a></p>\n</blockquote>\n<h2 id=\"预训练任务\"><a href=\"#预训练任务\" class=\"headerlink\" title=\"预训练任务\"></a>预训练任务</h2><p>ERNIE-Layout采用了四种预训练任务，包括新提出的阅读顺序预测（reading order prediction）、区域替换预测（replaced region prediction tasks）任务和传统的masked视觉语言建模、文本-图像对齐任务。</p>\n<ul>\n<li><p><strong>Reading Order Prediction：</strong> 希望注意矩阵能携带关于阅读顺序的知识，通过这种方式，我们赋予$\\hat A_{ij}$一个额外的含义，即第j个token是第i个token的下一个token的概率。此外，ground truth是一个0-1矩阵G，其中1表示两个token之间存在阅读顺序关系，反之亦然。对于最后一个token，下一个token是它自己。在预训练阶段，使用交叉熵损失函数。<br>$$<br>L_{ROP}&#x3D;-\\sum_{0\\le i &lt; N}\\sum_{0\\le j &lt; N}G_{ij}log(\\hat {A_{ij}})<br>$$</p>\n</li>\n<li><p><strong>Replaced Region Prediction：</strong> 在视觉编码器中，每个文档图像被处理成一个固定长度HW的序列。为了使模型能够感知图像块和文本之间的细粒度对应，在布局知识的帮助下，我们提出了区域替换预测(RRP)。具体来说，随机选取10%的图像块，用另一个图像中的块替换，处理后的图像由视觉编码器编码并输入到多模态 transformer中。然后，使用 transformer输出的[CLS]向量来预测哪些补丁被替换。所以这个任务的损失是：<br>$$<br>L_{RRP}&#x3D;-\\sum_{0 \\le i &lt;HW}[G_ilog(P_i)+(1-G_i)*log(1-P_i)]<br>$$<br>$G_i$是替换的图像块，$P_i$是规范化的概率。</p>\n</li>\n<li><p><strong>Masked Visual-Language Modeling</strong> ：类似 MLM（masked language modeling），MVLM（masked visual-language modeling）目标是根据masked文本上下文和整个多模态线索恢复masked文本token。</p>\n</li>\n<li><p><strong>Text-Image Alignment</strong> ：除了图像侧跨模态任务RRP，我们还采用了文本-图像对齐(TIA,Text-Image Alignment)作为文本侧任务，帮助模型学习图像区域与边界框坐标之间的空间对应关系。在这里，一些文本行是随机选择的，它们对应的区域覆盖在文档图像上。然后，引入分类层来预测每个文本标记是否被覆盖。</p>\n</li>\n</ul>\n<p>预训练任务的最终目标是<br>$$<br>L&#x3D;L_{ROP}+L_{RRP}+L_{MVLM}+L_{TIA}<br>$$</p>\n<h2 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h2><p>ERNIE-Layout有24个transformer层，1024个隐藏单元和16个注意头。文本token的最大序列长度为512，视觉token的最大序列长度为49。transformer初始化自RoBERTa large，视觉编码器采用Faster-RCNN 作为初始化模型。其余参数随机初始化。我们使用Adam作为优化器，学习率为1e-4，权值衰减为0.01。学习率在前10%的步骤中线性升温，然后线性衰减到0。ERNIE-Layout在24个Tesla A100 gpu上训练了20个epoch，batch大小为576。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>为了实验的公平性，我们只使用序列化来重新排列预训练数据的读取顺序，这意味着ERNIE-Layout在微调阶段接收到的输入与比较方法中输入是一样的。</p>\n<h3 id=\"Key-Information-Extraction\"><a href=\"#Key-Information-Extraction\" class=\"headerlink\" title=\"Key Information Extraction\"></a>Key Information Extraction</h3><p>ERNIE-Layout在FUNSD, CORD, Kleister-NDA上实现STOA，并在SROIE上实现了具有竞争力的性能。值得一提的是，在FUNSD中，ERNIE-Layout较之前的最佳结果获得了7.98%的显著稳定改善(标准差为0.0011)。以上现象足以验证我们在文档预训练模型中挖掘和利用布局知识的设计理念的有效性。</p>\n<p><img src=\"/2023/02/01/ERNIE-layout/image1.PNG\"></p>\n<p><img src=\"/2023/02/01/ERNIE-layout/image7.PNG\"></p>\n<h3 id=\"与最新的LayoutLMv3对比一下\"><a href=\"#与最新的LayoutLMv3对比一下\" class=\"headerlink\" title=\"与最新的LayoutLMv3对比一下\"></a>与最新的LayoutLMv3对比一下</h3><p><img src=\"/2023/02/01/ERNIE-layout/image8.PNG\"></p>\n<center><strong>LayoutLMv3 Large与ERNIE-layout Large 对比</strong></center>\n\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>FUNSD</th>\n<th>CORD</th>\n<th>DocVQA</th>\n<th>RVL-CDIP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>LayoutLMv3 large</strong></td>\n<td>92.08</td>\n<td><strong>97.46</strong></td>\n<td>83.37</td>\n<td>95.93</td>\n</tr>\n<tr>\n<td><strong>ERNIE-layout large</strong></td>\n<td><strong>93.12</strong></td>\n<td>97.21</td>\n<td><strong>88.41</strong></td>\n<td><strong>96.27</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"Document-Question-Answering\"><a href=\"#Document-Question-Answering\" class=\"headerlink\" title=\"Document Question Answering\"></a>Document Question Answering</h3><p>表4列出了平均归一化Levenshtein相似度(ANLS, Average Normalized Levenshtein Similarity) DocVQA评分。</p>\n<p>请注意，LayoutLMv2(#7)是基于UniLMv2(#3)开发的，该模型具有强大的问答能力，甚至在任务上击败了多模型LayoutLM(#4)。不幸的是，UniLMv2没有公开任何预训练代码或预训练模型，我们只能使用RoBERTa的参数来初始化我们的ERNIE-Layout。然而，我们感到惊讶的是ERNIE-Layout带来了令人兴奋的性能改进，(几乎是LayoutLMv2增加的两倍)。此外，我们使用模型集成在DocVQA排行榜上获得了第一名。</p>\n<p><img src=\"/2023/02/01/ERNIE-layout/image2.PNG\"></p>\n<h3 id=\"Document-Image-Classification\"><a href=\"#Document-Image-Classification\" class=\"headerlink\" title=\"Document Image Classification\"></a>Document Image Classification</h3><p>与这些重点关注多模态语义理解的关键信息提取或文档问答任务不同，文档图像分类需要对文本内容和文档布局的宏观感知。尽管我们的预训练任务关注的是细粒度的跨模态匹配，ERNIE-Layout仍然刷新跨粒度任务的最佳性能。</p>\n<img src=\"/2023/02/01/ERNIE-layout/image3.PNG\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"预训练分析\"><a href=\"#预训练分析\" class=\"headerlink\" title=\"预训练分析\"></a>预训练分析</h2><h3 id=\"预训练任务的分析\"><a href=\"#预训练任务的分析\" class=\"headerlink\" title=\"预训练任务的分析\"></a>预训练任务的分析</h3><p>在这个实验中，我们从基本的MVLM任务开始实现基线模型(#1)，并集成新的任务逐步直到最终模型包含所有四个训练任务(#5)。从表6中，我们观察到RRP带来了0.95%的改善FUNSD，展示了细粒度跨模态的相互作用。当加入ROP时，FUNSD的性能进一步提高1.3%。我们认为ROP有助于模型学习阅读顺序知识的更好表示。</p>\n<p><img src=\"/2023/02/01/ERNIE-layout/image4.PNG\"></p>\n<h3 id=\"注意力机制的有效性\"><a href=\"#注意力机制的有效性\" class=\"headerlink\" title=\"注意力机制的有效性\"></a>注意力机制的有效性</h3><p>LayoutLMv2 最初提出了空间感知的自注意，在注意力计算中考虑布局特征，后续许多方法都遵循这一思路。从表6中，我们发现采用这种机制可以提高下游任务的性能(#4 v.s. #6)。与此同时，将注意力分散到位置和内容部分是获得进一步性能提升的另一个有效解决方案(#5 v.s. #6)。</p>\n<h3 id=\"序列化模块的有效性\"><a href=\"#序列化模块的有效性\" class=\"headerlink\" title=\"序列化模块的有效性\"></a>序列化模块的有效性</h3><p>在这里，我们将探讨使用不同的序列化模块对下游VrDU任务的影响。如表7所示，使用基于布局知识的序列化模块(#2，#3)，模型可以获得更好的性能(即使没有解耦注意力)。我们将这种改进归因于这样一个事实:尽管序列化没有用于微调数据集，但在预训练后，模型有能力理解文档的正确阅读顺序。</p>\n<img src=\"/2023/02/01/ERNIE-layout/image5.PNG\" style=\"zoom:67%;\">\n\n\n\n<p>如图，一个复杂文档布局，使用raster-scanning order序列化为“… Session Chair: Session Chair: Session Chair: Tuula Hakkarainen …”，而使用Document-Parser序列化为：“… Session Chair: Tuula wz Session Chair: Frank Markert …”，这更符合人类的阅读习惯。</p>\n<img src=\"/2023/02/01/ERNIE-layout/image6.PNG\" style=\"zoom:67%;\">\n\n<p>使用Document-Parser序列化后，文档的PPL大幅下降。</p>\n","tags":["NLP"]},{"title":"Hexo & GitHub Pages 搭建博客","url":"/2023/01/08/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"<h1 id=\"Hexo-GitHub-Pages-搭建博客\"><a href=\"#Hexo-GitHub-Pages-搭建博客\" class=\"headerlink\" title=\"Hexo + GitHub Pages 搭建博客\"></a>Hexo + GitHub Pages 搭建博客</h1><p><strong>基本流程</strong></p>\n<ul>\n<li><p>搭建 Node.js 环境</p>\n</li>\n<li><p>搭建 Git 环境</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>GitHub 注册和配置</p>\n</li>\n<li><p>安装配置 Hexo</p>\n</li>\n<li><p>关联 Hexo 与 GitHub Pages</p>\n</li>\n<li><p>GitHub Pages 地址解析到个人域名</p>\n</li>\n<li><p>Hexo 的常用操作</p>\n</li>\n</ul>\n<h2 id=\"1-搭建-Node-js-环境\"><a href=\"#1-搭建-Node-js-环境\" class=\"headerlink\" title=\"1 搭建 Node.js 环境\"></a>1 搭建 Node.js 环境</h2><p><code>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的</code></p>\n<p><code>Node.js</code> 是一个基于<code> Chrome V8</code> 引擎的 <code>JavaScript </code>运行环境，可以在非浏览器环境下，解释运行 <code>JS </code>代码。</p>\n<p>在 <code>Node.js</code> 官网：<a href=\"https://link.jianshu.com/?t=https://nodejs.org/en/\">https://nodejs.org/en/</a> 下载安装包 <code>18.12.1 LTS</code></p>\n<p>保持默认设置即可，一路<code>Next</code>，安装很快就结束了。</p>\n<p>然后打开命令提示符，输入 <code>node -v</code>、<code>npm -v</code>，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;node -v</span><br><span class=\"line\">v18.13.0</span><br><span class=\"line\">&gt;npm -v</span><br><span class=\"line\">8.19.3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-搭建-Git-环境\"><a href=\"#2-搭建-Git-环境\" class=\"headerlink\" title=\"2 搭建 Git 环境\"></a>2 搭建 Git 环境</h2><p><code>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。</code></p>\n<p><code>Git </code>是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>\n<p>在<code> Git</code> 官网：<a href=\"https://git-scm.com/\">https://git-scm.com/</a> 下载安装包 <code>Git-2.39.0.2-64-bit.exe</code></p>\n<h2 id=\"3-GitHub-注册和配置\"><a href=\"#3-GitHub-注册和配置\" class=\"headerlink\" title=\"3 GitHub 注册和配置\"></a>3 GitHub 注册和配置</h2><p><code>GitHub </code>是一个代码托管平台，因为只支持 <code>Git </code>作为唯一的版本库格式进行托管，故名 GitHub。</p>\n<p><code>Github注册</code>：<a href=\"https://github.com/\">https://github.com/</a></p>\n<p>创建仓库：<code>Repository name </code>使用自己的用户名，仓库名规则：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">username.github.io</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：<code>uesrname</code> 必须是你的用户名。README初始化也要勾上</p>\n<p>访问 <code>username.github.io</code>，如果可以正常访问，那么 <code>Github</code> 的配置已经结束了。</p>\n<p><img src=\"/2023/01/08/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/repository_name.PNG\"></p>\n<h2 id=\"安装配置-Hexo\"><a href=\"#安装配置-Hexo\" class=\"headerlink\" title=\"安装配置 Hexo\"></a>安装配置 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。强烈建议你花20分钟区读一读 Hexo 的官方文档：<a href=\"https://link.jianshu.com/?t=https://hexo.io/zh-cn/\">https://hexo.io/zh-cn/</a></p>\n<p><strong>使用 npm 安装 Hexo</strong>：在命令行中输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;hexo -v</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo-cli: 4.3.0</span><br><span class=\"line\">os: win32 10.0.19044</span><br><span class=\"line\">node: 18.13.0</span><br><span class=\"line\">v8: 10.2.154.23-node.21</span><br><span class=\"line\">uv: 1.44.2</span><br><span class=\"line\">zlib: 1.2.13</span><br><span class=\"line\">brotli: 1.0.9</span><br><span class=\"line\">ares: 1.18.1</span><br><span class=\"line\">modules: 108</span><br><span class=\"line\">nghttp2: 1.51.0</span><br><span class=\"line\">napi: 8</span><br><span class=\"line\">llhttp: 6.0.10</span><br><span class=\"line\">uvwasi: 0.0.13</span><br><span class=\"line\">openssl: 3.0.7+quic</span><br><span class=\"line\">cldr: 42.0</span><br><span class=\"line\">icu: 72.1</span><br><span class=\"line\">tz: 2022f</span><br><span class=\"line\">unicode: 15.0</span><br><span class=\"line\">ngtcp2: 0.8.1</span><br><span class=\"line\">nghttp3: 0.7.0</span><br></pre></td></tr></table></figure>\n\n<p>执行下列命令来初始化我们的网站<code>blog</code>，Hexo 将会创建<code>blog</code>文件夹，文件夹中新建所需要的文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n\n<p>显示如下信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class=\"line\">fatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class=\"line\">WARN  git clone failed. Copying data instead</span><br><span class=\"line\">INFO  Install dependencies</span><br><span class=\"line\">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2023/01/08/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo.PNG\"></p>\n<p>新建完成后，<code>blog</code>文件夹的目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── .github        <span class=\"comment\"># 需要部署的文件夹</span></span><br><span class=\"line\">├── node_modules    <span class=\"comment\"># Hexo插件</span></span><br><span class=\"line\">├── scaffolds       <span class=\"comment\"># 模板</span></span><br><span class=\"line\">├── <span class=\"built_in\">source</span>          <span class=\"comment\"># 博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span></span><br><span class=\"line\">| └── _posts        <span class=\"comment\"># 文章</span></span><br><span class=\"line\">|    └── hello-world.md</span><br><span class=\"line\">├── themes          <span class=\"comment\"># 主题</span></span><br><span class=\"line\">├── _config.yml     <span class=\"comment\"># 全局配置文件</span></span><br><span class=\"line\">├── README.md     <span class=\"comment\"># 全局配置文件</span></span><br><span class=\"line\">├── .npmignore     </span><br><span class=\"line\">├── Gruntfile.js     <span class=\"comment\"># 全局配置文件</span></span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">└── package.json    <span class=\"comment\"># npm 依赖等</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>运行本地 Hexo 服务</strong></p>\n<p>接着输入<code>npm install</code>安装必备的组件</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>显示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">up to date, audited 236 packages in 6s</span><br><span class=\"line\"></span><br><span class=\"line\">20 packages are looking for funding</span><br><span class=\"line\">  run `npm fund` for details</span><br><span class=\"line\"></span><br><span class=\"line\">4 vulnerabilities (2 high, 2 critical)</span><br><span class=\"line\"></span><br><span class=\"line\">To address all issues (including breaking changes), run:</span><br><span class=\"line\">  npm audit fix --force</span><br><span class=\"line\"></span><br><span class=\"line\">Run `npm audit` for details.</span><br></pre></td></tr></table></figure>\n\n<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n\n<p>显示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 77 ms</span><br><span class=\"line\">INFO  Generated: archives/2023/index.html</span><br><span class=\"line\">INFO  Generated: archives/index.html</span><br><span class=\"line\">INFO  Generated: fancybox/fancybox_loading.gif</span><br><span class=\"line\">INFO  Generated: index.html</span><br><span class=\"line\">INFO  Generated: fancybox/blank.gif</span><br><span class=\"line\">INFO  Generated: fancybox/fancybox_sprite@2x.png</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/fancybox_buttons.png</span><br><span class=\"line\">INFO  Generated: fancybox/fancybox_loading@2x.gif</span><br><span class=\"line\">INFO  Generated: fancybox/fancybox_overlay.png</span><br><span class=\"line\">INFO  Generated: fancybox/fancybox_sprite.png</span><br><span class=\"line\">INFO  Generated: js/script.js</span><br><span class=\"line\">INFO  Generated: css/fonts/fontawesome-webfont.ttf</span><br><span class=\"line\">INFO  Generated: archives/2023/01/index.html</span><br><span class=\"line\">INFO  Generated: fancybox/jquery.fancybox.css</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.js</span><br><span class=\"line\">INFO  Generated: css/style.css</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.css</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/jquery.fancybox-media.js</span><br><span class=\"line\">INFO  Generated: fancybox/jquery.fancybox.pack.js</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.css</span><br><span class=\"line\">INFO  Generated: css/fonts/fontawesome-webfont.eot</span><br><span class=\"line\">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.js</span><br><span class=\"line\">INFO  Generated: fancybox/jquery.fancybox.js</span><br><span class=\"line\">INFO  Generated: css/images/banner.jpg</span><br><span class=\"line\">INFO  Generated: css/fonts/fontawesome-webfont.svg</span><br><span class=\"line\">INFO  Generated: 2023/01/07/hello-world/index.html</span><br><span class=\"line\">INFO  Generated: css/fonts/fontawesome-webfont.woff</span><br><span class=\"line\">INFO  Generated: css/fonts/FontAwesome.otf</span><br><span class=\"line\">INFO  28 files generated in 195 ms</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo server</span><br><span class=\"line\">或者</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>显示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>您的网站会在 <a href=\"https://link.jianshu.com/?t=http://localhost:4000\">http://localhost:4000</a> 下启动。如果 <a href=\"https://link.jianshu.com/?t=http://localhost:4000\">http://localhost:4000</a> 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p>\n<h2 id=\"关联-Hexo-与-GitHub-Pages\"><a href=\"#关联-Hexo-与-GitHub-Pages\" class=\"headerlink\" title=\"关联 Hexo 与 GitHub Pages\"></a>关联 Hexo 与 GitHub Pages</h2><p>首先右键打开<code>Git bash</code>，然后输入下面命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们如何让本地<code>Git</code>项目与远程的<code>Github</code>建立联系呢？用 <code>SSH keys</code></p>\n<p><strong>生成SSH keys</strong></p>\n<p>输入你自己的邮箱地址</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;XX<span class=\"keyword\">@qq</span>.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。</p>\n<p><strong>添加 SSH Key 到 GitHub</strong></p>\n<p>打开 <code>C:\\Users\\XX\\.ssh\\id_rsa.pub</code>，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 <a href=\"https://link.jianshu.com/?t=https://github.com/settings/ssh\">https://github.com/settings/ssh</a> 的 <code>new SSH key</code> 中</p>\n<p><strong>测试</strong></p>\n<p>可以输入下面的命令，看看设置是否成功，<a href=\"https://link.jianshu.com/?t=mailto:git@github.com\">git@github.com</a>的部分不要修改：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -T git<span class=\"keyword\">@github</span>.com</span><br></pre></td></tr></table></figure>\n\n<p>如果是下面的反馈：</p>\n<blockquote>\n<p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes&#x2F;no)?</p>\n</blockquote>\n<p>不要紧张，输入yes就好，然后会看到：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi coder4nlp! You<span class=\"symbol\">&#x27;ve</span> successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置Git个人信息</strong></p>\n<p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br> Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name coder4nlp</span><br><span class=\"line\">git config --global user.email &quot;XX@qq.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置 Deployment</strong></p>\n<p>在<code>_config.yml</code>文件中，找到<code>Deployment</code>，然后按照如下修改，用户名改成你的：</p>\n<p>需要注意的是：冒号后面记得空一格！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: <span class=\"string\">&#x27;git&#x27;</span></span><br><span class=\"line\">  repo: git@github.com:coder4nlp/coder4nlp.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\n\n<p><strong>本地文件提交到 GitHub Pages</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除旧的 public 文件</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成新的 public 文件</span></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">或者</span><br><span class=\"line\">hexo g</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>开始部署</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br><span class=\"line\">或者</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>显示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>\n\n<p>操作失败，则需要安装一个扩展</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器中输入 <a href=\"https://coder4nlp.github.io/%EF%BC%88%E7%94%A8%E6%88%B7%E5%90%8D%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%EF%BC%89%E7%9C%8B%E5%88%B0%E4%BA%86\">https://coder4nlp.github.io/（用户名改成你的）看到了</a> Hexo 与 GitHub Pages 已经成功关联了.</p>\n<p><strong>注意</strong>：怎么避免 .md 文件被解析？</p>\n<p>Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到<code>public</code>文件夹中，在执行<code>hexo deploy</code>时将其复制到<code>.deploy_git</code>文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。怎么解决呢？</p>\n<p>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p>\n<h2 id=\"GitHub-Pages-地址解析到个人域名\"><a href=\"#GitHub-Pages-地址解析到个人域名\" class=\"headerlink\" title=\"GitHub Pages 地址解析到个人域名\"></a>GitHub Pages 地址解析到个人域名</h2><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。</p>\n<p>看着博客的域名是二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我在阿里云上买了一个域名，打算将博客绑定自己的域名。</p>\n<p>进行该绑定过程，其实就是一个重定向的过程。</p>\n<p>在 GitHub 仓库的根目录下建立一个 <code>CNAME</code> 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加<code>http://</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">www<span class=\"selector-class\">.lovebxm</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：CNAME 一定是在你 Github 项目的 master 根目录下</p>\n<p>进入<a href=\"https://link.jianshu.com/?t=https://dc.aliyun.com/tcparse/dns.htm\">阿里云域名解析地</a>址，添加解析：</p>\n<ol>\n<li>记录类型选择<code>CNAME</code></li>\n<li>主机记录填<code>www</code></li>\n<li>解析线路选择<code>默认</code></li>\n<li>记录值填<code>yourname.github.io</code></li>\n<li>TTL值为<code>10</code>分钟</li>\n<li>再添加一个解析，记录类型<code>A</code></li>\n<li>主机记录填<code>www</code></li>\n<li>解析线路选择<code>默认</code></li>\n<li>记录值填你GitHub 的ip地址（在cmd中ping：）</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping bxm0927<span class=\"selector-class\">.github</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5832745-cffe7e98c478b96e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp\" alt=\"img\"></p>\n<p>点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。</p>\n<p>域名绑定成功，域名解析成功，因此你在浏览中输入 <a href=\"https://link.jianshu.com/?t=http://www.lovebxm.com\">www.lovebxm.com</a>，或 <a href=\"https://link.jianshu.com/?t=http://lovebxm.com\">lovebxm.com</a> 就可以访问到博客了，输入 <a href=\"https://link.jianshu.com/?t=http://bxm0927.github.io\">bxm0927.github.io</a> 会重定向到  <a href=\"https://link.jianshu.com/?t=http://www.lovebxm.com\">www.lovebxm.com</a>。过程：www 的方式，会先解析成 <a href=\"https://link.jianshu.com/?t=http://xxxx.github.io\">http://xxxx.github.io</a>，然后根据 CNAME 再变成 www</p>\n<p><strong>注意</strong>：CNAME文件在下次 <code>hexo deploy</code>的时候就消失了，需要重新创建，这样就很繁琐</p>\n<p>方法一：每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件</p>\n<p>方法二：在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 “\\public” 目录下面，里面写入你要绑定的域名。</p>\n<p>方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。</p>\n<p>方法四：通过安装插件实现永久保留</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure>\n\n<p>之后在_config.yml中添加一条</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins:</span><br><span class=\"line\">- hexo-generator-cname</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。</p>\n<p><strong>注意1</strong>：每次生成的 CNAME 都是 yoursite.com 怎么解决？</p>\n<p>修改 _config.yml</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: http:<span class=\"comment\">//www.lovebxm.com</span></span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">permalink_defaults:</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hexo-的常用操作\"><a href=\"#Hexo-的常用操作\" class=\"headerlink\" title=\"Hexo 的常用操作\"></a>Hexo 的常用操作</h2><h3 id=\"发表一篇文章\"><a href=\"#发表一篇文章\" class=\"headerlink\" title=\"发表一篇文章\"></a>发表一篇文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;文章标题&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">D:\\GitHub\\Hexo\\<span class=\"built_in\">test</span>&gt;hexo new <span class=\"string\">&quot;文章标题&quot;</span></span><br><span class=\"line\">INFO  Created: D:\\GitHub\\Hexo\\<span class=\"built_in\">test</span>\\<span class=\"built_in\">source</span>\\_posts\\文章标题.md</span><br></pre></td></tr></table></figure>\n\n<p>在本地博客文件夹 <code>source\\_posts</code> 文件夹下，可以发现下面多了一个<code>.md</code>文件</p>\n<p>当然，我们也可以手动添加Markdown文件在<code>source\\_posts</code>文件夹下，其效果同样可以媲美<code>hexo new</code></p>\n<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo d -g</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"新建一个自定义页面\"><a href=\"#新建一个自定义页面\" class=\"headerlink\" title=\"新建一个自定义页面\"></a>新建一个自定义页面</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> page folder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改主题\"><a href=\"#更改主题\" class=\"headerlink\" title=\"更改主题\"></a>更改主题</h3><p>官方主题库：<a href=\"https://link.jianshu.com/?t=https://hexo.io/themes/\">https://hexo.io/themes/</a></p>\n<p>Hexo主题非常，推荐使用 <code>Next</code> 为主题，请阅读 Next 的官方文档（ <a href=\"https://link.jianshu.com/?t=http://theme-next.iissnan.com/\">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</p>\n<p>再提示一点，大家可以hexo主题修改一步就hexo s看下变化，初次接触对参数不清楚。只有hexo s后在可以在本地浏览到效果，Ctrl+C 停止服务器。</p>\n<p>在 <code>themes</code> 文件夹中创建文件夹 <code>Hacker</code> ，将主题文件都复制粘贴至 <code>Hacker</code> 文件夹；</p>\n<p>然后在hexo全局配置文件 <code>_config.yml</code> 中应用主题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme: Hacker</span><br></pre></td></tr></table></figure>\n\n<p>更换next主题，在<code>hexo s</code>时警告，页面空白，使用<code>hexo clean</code>解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">WARN  No layout: index.html</span><br><span class=\"line\">WARN  No layout: index.html</span><br><span class=\"line\">WARN  No layout: index.html</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n\n<p>next主题配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page about</span><br><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>tags：</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>title: 分类 #页面的头部显示<br>type: categories</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- categories：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>title: 标签 #页面的头部显示<br>type: tags</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 添加站点访问人数和总访问量</span><br><span class=\"line\"></span><br><span class=\"line\">修改next主题配置文件，搜索**busuanzi_count**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>busuanzi_count:<br>enable: true<br>total_visitors: true<br>total_visitors_icon: user<br>total_views: true<br>total_views_icon: eye<br>post_views: true<br>post_views_icon: eye</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 添加搜索功能</span><br><span class=\"line\"></span><br><span class=\"line\">在博客根目录安装搜索插件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm install hexo-generator-search –save # 安装插件，用于生成博客索引数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">修改博客配置文件（根目录/_config.yml），添加以下代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>search:<br>path: search.json #之前就是这里出了问题导致图标错误，错误的教程是 search.xml<br>field: post<br>format: html<br>limit: 1000</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">修改主题的根目录配置文件(themes\\next_config.yml)，把enable的false改为true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>local_search:<br>enable: true</p>\n<h1 id=\"if-auto-trigger-search-by-changing-input\"><a href=\"#if-auto-trigger-search-by-changing-input\" class=\"headerlink\" title=\"if auto, trigger search by changing input\"></a>if auto, trigger search by changing input</h1><h1 id=\"if-manual-trigger-search-by-pressing-enter-key-or-search-button\"><a href=\"#if-manual-trigger-search-by-pressing-enter-key-or-search-button\" class=\"headerlink\" title=\"if manual, trigger search by pressing enter key or search button\"></a>if manual, trigger search by pressing enter key or search button</h1><p>trigger: auto</p>\n<h1 id=\"show-top-n-results-per-article-show-all-results-by-setting-to-1\"><a href=\"#show-top-n-results-per-article-show-all-results-by-setting-to-1\" class=\"headerlink\" title=\"show top n results per article, show all results by setting to -1\"></a>show top n results per article, show all results by setting to -1</h1><p>top_n_per_article: 1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">但是！！！！！！根据网络上的教程，我的搜索功能一部署到服务器就出现了搜索图标不正常显示，然后费劲九牛二虎之力才发现。那些教程只适用于旧版的hexo。</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy56enp5dWFuLmNuLzIwMjAwNzA1MTYzODU4LmpwZw?x-oss-process=image/format,png)</span><br><span class=\"line\"></span><br><span class=\"line\">安装插件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm install hexo-generator-searchdb –save # 安装插件，用于生成博客索引数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">还是没有用，因为我用的hexo版本是5.4.2，所以next主题也要使用最新的，我安装的是8.14.2版本，解决搜索框问题</span><br><span class=\"line\"></span><br><span class=\"line\">NexT 一共有三个不同的仓库：</span><br><span class=\"line\"></span><br><span class=\"line\">| 版本            | 年份        | 仓库                                          |</span><br><span class=\"line\">| --------------- | ----------- | --------------------------------------------- |</span><br><span class=\"line\">| v5.1.4 或更低   | 2014 ~ 2017 | https://github.com/iissnan/hexo-theme-next    |</span><br><span class=\"line\">| v6.0.0 ~ v7.8.0 | 2018 ~ 2019 | https://github.com/theme-next/hexo-theme-next |</span><br><span class=\"line\">| v8.0.0 或更高   | 2020        | https://github.com/next-theme/hexo-theme-next |</span><br><span class=\"line\"></span><br><span class=\"line\">If you&#x27;re using **Hexo 5.0** or later, the simplest way to install is through npm:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cd hexo-site<br>$ npm install hexo-theme-next</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Or you can clone the entire repository:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cd hexo-site<br>$ git clone <a href=\"https://github.com/next-theme/hexo-theme-next\">https://github.com/next-theme/hexo-theme-next</a> themes&#x2F;next</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">与插件配合，搜索正常</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm install hexo-generator-searchdb –save # 安装插件，用于生成博客索引数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 添加字数统计及阅读时长</span><br><span class=\"line\"></span><br><span class=\"line\">安装hexo-symbols-count-time</span><br><span class=\"line\"></span><br><span class=\"line\">在博客文件夹里执行命令：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm install hexo-symbols-count-time –save</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 启用分类和标签页面</span><br><span class=\"line\"></span><br><span class=\"line\">分类功能：执行 `hexo new page categories` ，然后修改生成的 `source/categories/index.md` </span><br><span class=\"line\"></span><br><span class=\"line\">### 文章如何添加多个标签</span><br><span class=\"line\"></span><br><span class=\"line\">有两种多标签格式</span><br><span class=\"line\"></span><br><span class=\"line\">```swift</span><br><span class=\"line\">tags: [a, b, c]</span><br><span class=\"line\">或</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - a</span><br><span class=\"line\">  - b</span><br><span class=\"line\">  - c</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"显示部分文章内容\"><a href=\"#显示部分文章内容\" class=\"headerlink\" title=\"显示部分文章内容\"></a>显示部分文章内容</h3><p>如果在博客文章列表中，不想全文显示，可以增加 <code>&lt;!--more--&gt;</code>, 后面的内容就不会显示在列表。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入本地图片\"><a href=\"#插入本地图片\" class=\"headerlink\" title=\"插入本地图片\"></a>插入本地图片</h2><p>在<code>_posts</code>目录下新建文章的时候，通过\t<code>markdown</code>语法可以插入本地图片正常显示。但是在<code>hexo g</code>生成的静态网页中，同目录下的图片被复制到博客所在目录<code>blog\\public\\2023\\01\\08\\Hexo-GitHub-Pages-搭建博客</code>，与<code>index.html</code>在同样的目录，<code>hexo s</code>和<code>hexo d</code>时，图片不能正常显示。</p>\n<p>在markdown中插入图片，在Markdown中可以正常显示图片，在服务中无法正常显示。</p>\n<p><code>![](Hexo-GitHub-Pages-搭建博客/hexo.PNG)</code></p>\n<p>在静态网页中的源码为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo.PNG&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h3><p>在source目录下新建一个目录 <code>images</code>，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法访问它们。但是在本地markdwon文件中无法进行预览，使用hexo s或者hexo g时，图片正常显示。</p>\n<p>在 <code>source</code> 目录下创建一个名为 <code>images</code> 的文件夹专门用于存放图片，会把 <code>source/images</code> 这个文件夹复制到 <code>public/images</code> ，即部署后的站点根目录下，到时候可以通过绝对路径很方便的获取到 images 里面的图片。</p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><p>首先引用 hexo-renderer-marked 包，虽然有报错，但是不影响使用。但是卸载的时候会导致其他的依赖被删除，无法打开网站。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;npm install hexo-renderer-marked --save</span><br><span class=\"line\"></span><br><span class=\"line\">added 62 packages, and audited 263 packages in 6s</span><br><span class=\"line\"></span><br><span class=\"line\">22 packages are looking for funding</span><br><span class=\"line\">  run `npm fund` for details</span><br><span class=\"line\"></span><br><span class=\"line\">6 vulnerabilities (5 high, 1 critical)</span><br><span class=\"line\"></span><br><span class=\"line\">Some issues need review, and may require choosing</span><br><span class=\"line\">a different dependency.</span><br><span class=\"line\"></span><br><span class=\"line\">Run `npm audit` for details.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>安装这个报之后，图片链接变成如下所示，带上文件夹路径<code>/2023/01/08</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;/2023/01/08/Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo.PNG&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"添加插件\"><a href=\"#添加插件\" class=\"headerlink\" title=\"添加插件\"></a>添加插件</h3><p>添加 sitemap 和 feed 插件</p>\n<p>切换到你本地的 hexo 目 CIA ，在命令行窗口，输入以下命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed -save</span><br><span class=\"line\">npm install hexo-generator-sitemap -save</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>_config.yml</code>，增加以下内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extensions</span></span><br><span class=\"line\">Plugins:</span><br><span class=\"line\">- hexo-generator-feed</span><br><span class=\"line\">- hexo-generator-sitemap</span><br><span class=\"line\"><span class=\"comment\">#Feed Atom</span></span><br><span class=\"line\">feed:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  <span class=\"built_in\">limit</span>: 20</span><br><span class=\"line\"><span class=\"comment\">#sitemap</span></span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p>再执行以下命令，部署服务端</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>配完之后，就可以访问 <a href=\"https://link.jianshu.com/?t=https://bxm0927.github.io/atom.xml\">https://bxm0927.github.io/atom.xml</a> 和 <a href=\"https://link.jianshu.com/?t=https://bxm0927.github.io/sitemap.xml\">https://bxm0927.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p>\n<h3 id=\"添加-404-页面\"><a href=\"#添加-404-页面\" class=\"headerlink\" title=\"添加 404 页面\"></a>添加 404 页面</h3><p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5832745-61e2dcbbdd421a12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/667/format/webp\" alt=\"img\"></p>\n<p>其实，404页面可以做更多有意义的事，来做个404公益项目吧。</p>\n<p>推荐使用腾讯公益404 <a href=\"https://link.jianshu.com/?t=http://www.qq.com/404/\">http://www.qq.com/404/</a> ：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">src</span>=<span class=\"string\">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">homePageUrl</span>=<span class=\"string\">&quot;http://www.lovebxm.com/&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">homePageName</span>=<span class=\"string\">&quot;回到我的主页&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>复制上面代码，贴粘到目录下新建的404.html即可！</p>\n<h2 id=\"修改字体\"><a href=\"#修改字体\" class=\"headerlink\" title=\"修改字体\"></a>修改字体</h2><p>默认<code>NexT</code>使用微软雅黑字体，当前调整中文字体为思源宋体（<code>Noto Serif SC</code>）</p>\n<p>修改<code>NexT _config.yml</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ---------------------------------------------------------------</span><br><span class=\"line\"># Font Settings</span><br><span class=\"line\"># ---------------------------------------------------------------</span><br><span class=\"line\"># Find fonts on Google Fonts (https://fonts.google.com)</span><br><span class=\"line\"># All fonts set here will have the following styles:</span><br><span class=\"line\">#   light | light italic | normal | normal italic | bold | bold italic</span><br><span class=\"line\"># Be aware that setting too much fonts will cause site running slowly</span><br><span class=\"line\"># ---------------------------------------------------------------</span><br><span class=\"line\"># Web Safe fonts are recommended for `global` (and `title`):</span><br><span class=\"line\"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span><br><span class=\"line\"># ---------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">font:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\"></span><br><span class=\"line\">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class=\"line\">  host: https://fonts.lug.ustc.edu.cn</span><br><span class=\"line\"></span><br><span class=\"line\">  # Font options:</span><br><span class=\"line\">  # `external: true` will load this font family from `host` above.</span><br><span class=\"line\">  # `family: Times New Roman`. Without any quotes.</span><br><span class=\"line\">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class=\"line\"></span><br><span class=\"line\">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class=\"line\">  global:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\">    # family: Lato</span><br><span class=\"line\">    family: Noto Serif SC</span><br><span class=\"line\">    size:</span><br><span class=\"line\"></span><br><span class=\"line\">  # Font settings for site title (.site-title).</span><br><span class=\"line\">  title:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\">    family:</span><br><span class=\"line\">    size:</span><br><span class=\"line\"></span><br><span class=\"line\">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class=\"line\">  headings:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\">    family:</span><br><span class=\"line\">    size:</span><br><span class=\"line\"></span><br><span class=\"line\">  # Font settings for posts (.post-body).</span><br><span class=\"line\">  posts:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\">    family:</span><br><span class=\"line\"></span><br><span class=\"line\">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class=\"line\">  codes:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\">    family:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置<code>font enable</code>属性为<code>true</code></li>\n<li>设置<code>host</code>属性为<code>https://fonts.lug.ustc.edu.cn</code></li>\n<li>设置<code>global external</code>属性为<code>true</code></li>\n<li>设置<code>global family</code>属性为<code>Noto Serif SC</code></li>\n</ul>\n<h3 id=\"多PC同步管理博客\"><a href=\"#多PC同步管理博客\" class=\"headerlink\" title=\"多PC同步管理博客\"></a>多PC同步管理博客</h3><p>很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。</p>\n<ol>\n<li>A电脑备份博客内容到github</li>\n</ol>\n<p>配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容&#x2F;.deploy_git和&#x2F;public</p>\n<ol>\n<li>初始化仓库。</li>\n</ol>\n<p>在博客根目录下，在git bash下依次执行git init和git remote add origin <server> <server>为远程仓库地址。</server></server></p>\n<ol>\n<li>同步到远程仓库。</li>\n</ol>\n<p>gitbash下依次执行以下命令</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">add</span> . <span class=\"meta\">#添加目录下所有文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新说明&quot;</span> <span class=\"meta\">#提交并添加更新说明</span></span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master <span class=\"meta\">#推送更新到远程仓库</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>B电脑拉下远程仓库文件</li>\n</ol>\n<p>在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">init</span></span><br><span class=\"line\"></span><br><span class=\"line\">git remote <span class=\"keyword\">add</span> origin &lt;server&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch --all</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>发布博客后同步</li>\n</ol>\n<p>在B电脑发布完博客之后，记得将博客备份同步到远程仓库<br> 执行以下命令：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">add</span> .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#可以用git master 查看更改内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新信息&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master  <span class=\"meta\">#以后每次提交可以直接git push</span></span><br></pre></td></tr></table></figure>\n\n<p>平时同步管理<br> 每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。</p>\n<h3 id=\"中文乱码\"><a href=\"#中文乱码\" class=\"headerlink\" title=\"中文乱码\"></a>中文乱码</h3><p>在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为<code>UTF-8</code>编码的文件即可解决问题。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>建站的系统有很多，如：</p>\n<ul>\n<li><a href=\"https://link.jianshu.com/?t=https://hexo.io/zh-cn/\">Hexo + GitHub Pages</a></li>\n<li><a href=\"https://link.jianshu.com/?t=http://jekyll.com.cn/\">Jekyll + GitHub Pages</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https://cn.wordpress.org/\">WordPress + 服务器 + 域名</a></li>\n<li><a href=\"https://link.jianshu.com/?t=http://www.dedecms.com/\">DeDeCMS + 服务器 + 域名</a></li>\n<li>…</li>\n</ul>\n<p>使用 Hexo + GitHub Pages 建站，有优点也有缺点：</p>\n<ul>\n<li>GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。</li>\n<li>但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。</li>\n<li>个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 <a href=\"https://link.jianshu.com/?t=https://gentie.163.com/info.html\">网易云跟帖</a>就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。</li>\n<li>通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！</li>\n</ul>\n<p>推荐几个很好用的在线 Markdown 编辑器：</p>\n<ul>\n<li>作业部落：<a href=\"https://link.jianshu.com/?t=https://www.zybuluo.com/mdeditor\">https://www.zybuluo.com/mdeditor</a></li>\n<li>马克飞象：<a href=\"https://link.jianshu.com/?t=https://maxiang.io\">https://maxiang.io</a></li>\n</ul>\n<p>推荐图床：</p>\n<ul>\n<li><a href=\"https://link.jianshu.com/?t=https://jiantuku.com/#/\">极简图床 + chrome 插件 + 七牛空间</a>，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.jianshu.com/p/39562a0d8eb6\">https://www.jianshu.com/p/39562a0d8eb6</a></p>\n<p><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>\n<p><a href=\"https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/\">https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</a></p>\n"},{"title":"Hugging Face的Datasets 库","url":"/2023/01/10/Hugging-Face%E7%9A%84Datasets-%E5%BA%93/","content":"<p><code>Datasets</code>是一个轻量级库，提供两个主要特性:</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>用于许多公开数据集的单行<strong>dataloaders</strong>：只需一行程序即可下载和预处理<code>HuggingFace</code>数据集中心提供的任何数量的主要公开数据集(图像数据集、音频数据集、467种语言和方言的文本数据集等)。使用一个简单的命令，如<code>squad_dataset = load_dataset(&quot;squad&quot;)</code>，即可获取任何这些数据集，准备在数据加载器中使用，用于训练&#x2F;评估ML模型(<code>Numpy/Pandas/PyTorch/TensorFlow/JAX</code>)</li>\n<li>高效的数据预处理：简单，快速和可重复的数据预处理，用于公开数据集以及您自己的<code>CSV</code>, <code>JSON</code>，<code>text</code>，<code>PNG</code>，<code>JPEG</code>，<code>WAV</code>,，<code>MP3</code>, <code>Parquet</code>等本地数据集。使用<code>processed_dataset = dataset.map(process_example)</code>这样的简单命令，可以有效地为ML模型评估和训练准备数据集。</li>\n</ul>\n<p>Datasets旨在让社区轻松添加和共享新的数据集。</p>\n<p><code>Datasets</code>有许多其他有趣的特性:</p>\n<ul>\n<li><p>在大型数据集上发展：数据集自然地将用户从RAM内存限制中解放出来，所有数据集都使用高效的<code>zero-serialization cost backend</code>(Apache Arrow)进行内存映射。</p>\n</li>\n<li><p>智能缓存：永远不要等待您的数据处理多次。</p>\n</li>\n<li><p>轻量级且快速，使用透明的<code>python API</code>(多处理&#x2F;缓存&#x2F;内存映射)。</p>\n</li>\n<li><p>内置与<code>NumPy</code>, <code>Pandas</code>, <code>PyTorch</code>, <code>Tensorflow 2</code>和<code>JAX</code>的互操作性。</p>\n</li>\n<li><p>对音频和图像数据的原生支持。</p>\n</li>\n<li><p>启用流模式以节省磁盘空间并立即开始遍历数据集。</p>\n<p><code>Datasets</code>起源于很棒的<a href=\"https://github.com/tensorflow/datasets\">TensorFlow Datasets</a> 的一个分支，HuggingFace团队想要深切感谢<code>TensorFlow Datasets</code>团队构建这个惊人的库。关于<code>Datasets</code>和<code>tfds</code>之间差异的更多详细信息，可以在<a href=\"https://github.com/huggingface/datasets#main-differences-between--datasets-and-tfds\">Main differences between 🤗 Datasets and <code>tfds</code></a>部分中找到。</p>\n</li>\n</ul>\n<h1 id=\"从hub加载一个数据\"><a href=\"#从hub加载一个数据\" class=\"headerlink\" title=\"从hub加载一个数据\"></a>从hub加载一个数据</h1><p>找到可复现和可访问的高质量数据集可能很困难。<code>Datasets</code>的主要目标之一是提供一种简单的方法来加载任何格式或类型的数据集。最简单的入门方法是在<a href=\"https://huggingface.co/datasets\">Hugging Face Hub</a> 上发现现有数据集(一个社区驱动的数据集集合，用于自然语言处理、计算机视觉和音频任务)，并使用<code>Datasets</code>下载并生成数据集。</p>\n<p>本教程使用<a href=\"https://huggingface.co/datasets/rotten_tomatoes\">rotten_tomatoes</a>和<a href=\"https://huggingface.co/datasets/PolyAI/minds14\">MInDS-14</a>数据集，但请随意加载任何你想要的数据集并跟随。现在前往Hub，为您的任务找到一个数据集!</p>\n<h2 id=\"加载一个数据\"><a href=\"#加载一个数据\" class=\"headerlink\" title=\"加载一个数据\"></a>加载一个数据</h2><p>在花时间下载数据集之前，快速获取关于数据集的一些一般信息通常是有帮助的。数据集的信息存储在 <a href=\"https://huggingface.co/docs/datasets/v2.6.1/en/package_reference/main_classes#datasets.DatasetInfo\">DatasetInfo</a>中，可以包括数据集描述、特征和数据集大小等信息。</p>\n<p>使用<a href=\"https://huggingface.co/docs/datasets/v2.6.1/en/package_reference/loading_methods#datasets.load_dataset_builder\">load_dataset_builder()</a>函数加载数据集构建器，并检查数据集的属性，而不是下载数据集:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from datasets import load_dataset_builder</span><br><span class=\"line\">ds_builder = load_dataset_builder(&quot;rotten_tomatoes&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">ds_builder.info.description</span><br><span class=\"line\"></span><br><span class=\"line\">ds_builder.info.features</span><br></pre></td></tr></table></figure>\n\n<p>如果你对数据集满意，那么用<code>load_dataset()</code>加载它:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from datasets import load_dataset</span><br><span class=\"line\">dataset = load_dataset(&quot;rotten_tomatoes&quot;, split=&quot;train&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"划分\"><a href=\"#划分\" class=\"headerlink\" title=\"划分\"></a>划分</h2><p>一个划分是数据集的特定子集(如<code>train</code>和<code>test</code>)。使用<code>get_dataset_split_names()</code>函数列出数据集的拆分名称:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> datasets <span class=\"keyword\">import</span> get_dataset_split_names</span><br><span class=\"line\"></span><br><span class=\"line\">get_dataset_split_names(<span class=\"string\">&quot;rotten_tomatoes&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后你可以用<code>split</code>参数加载一个特定的划分。加载一个数据集划分返回一个<code>Dataset</code>对象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> datasets <span class=\"keyword\">import</span> load_dataset</span><br><span class=\"line\"></span><br><span class=\"line\">dataset = load_dataset(<span class=\"string\">&quot;rotten_tomatoes&quot;</span>, split=<span class=\"string\">&quot;train&quot;</span>)</span><br><span class=\"line\">dataset</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dataset(&#123;</span><br><span class=\"line\">    features: [&#x27;text&#x27;, &#x27;label&#x27;],</span><br><span class=\"line\">    num_rows: 8530</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果你没有指定<code>split</code>，<code>Datasets</code>会返回一个<code>DatasetDict</code>对象:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from datasets import load_dataset</span><br><span class=\"line\"></span><br><span class=\"line\">dataset = load_dataset(&quot;rotten_tomatoes&quot;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DatasetDict(&#123;</span><br><span class=\"line\">    train: Dataset(&#123;</span><br><span class=\"line\">        features: [&#x27;text&#x27;, &#x27;label&#x27;],</span><br><span class=\"line\">        num_rows: 8530</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    validation: Dataset(&#123;</span><br><span class=\"line\">        features: [&#x27;text&#x27;, &#x27;label&#x27;],</span><br><span class=\"line\">        num_rows: 1066</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    test: Dataset(&#123;</span><br><span class=\"line\">        features: [&#x27;text&#x27;, &#x27;label&#x27;],</span><br><span class=\"line\">        num_rows: 1066</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://huggingface.co/docs/datasets/load_hub\">https://huggingface.co/docs/datasets/load_hub</a></p>\n<p><a href=\"https://huggingface.co/docs/datasets/index\">https://huggingface.co/docs/datasets/index</a></p>\n"},{"title":"Vision-Language Pretraining &#58 Current Trends and the Future","url":"/2023/01/15/vision-language/","content":"<p>由<a href=\"https://www.iro.umontreal.ca/~agrawal/\">Aishwarya Agrawal</a> (DeepMind，蒙特利尔大学，Mila)， <a href=\"http://www.damienteney.info/\">Damien Teney</a> (Idiap研究所)和<a href=\"http://www.aidanematzadeh.me/\">Aida Nematzadeh</a> (DeepMind)编写的ACL 2022教程。</p>\n<span id=\"more\"></span>\n\n<p>幻灯片：</p>\n<p>• Part 1: <a href=\"https://drive.google.com/file/d/1e0oLeQ2QrGcyP5OdINKhVDAjrCxtIIPV/view?usp=sharing\">Vision-language landscape before the pretraining era</a>.<br>• Part 2: <a href=\"https://vlp-tutorial-acl2022.github.io/part2_pretraining_models_aida.pdf\">Modern vision-language pretraining</a>.<br>• Part 3: <a href=\"https://vlp-tutorial-acl2022.github.io/Part3_BeyondStatisticalLearning_Teney.pdf\">Beyond statistical learning</a>.</p>\n<p>本教程的目标是概述解决多模态问题所需的要素，特别是视觉和语言。我们还将讨论这一领域的一些悬而未决的问题和有前景的未来方向。</p>\n<p>在过去的几年里，人们对构建多模态(视觉-语言)模型越来越感兴趣，这种模型是在更大但更嘈杂的数据集上预训练的，其中两种模态(例如，图像和文本)彼此不精确地对应(例如，ViLBERT和CLIP)。给定一个任务(例如视觉问题回答)，这些模型通常会在特定于任务的监督数据集上进行微调。除了更大的预训练数据集外，transformer架构和应用于两种模态的自注意力是最近的预训练模型在下游任务中令人印象深刻的表现的原因。这种方法很有吸引力，原因有几个：首先，预训练数据集通常是从网络自动爬取的，提供了可以忽略不计的收集成本的庞大数据集。其次，我们可以训练大模型一次，并在各种任务中复用它们。最后，这些预训练方法的性能优于或与之前的特定任务模型相当。一个有趣的问题是，除了良好的任务表现外，这些预训练的模型是否能够更好地捕捉两种模态之间的对齐。在本教程中，我们关注最近的视觉语言预训练范式。我们的目标是在多模态预训练领域之前，首先提供图像语言数据集、基准和建模创新的背景。接下来，我们将讨论用于视觉-语言预训练的不同类型模型，重点介绍它们的优缺点。最后，我们讨论了通过统计学习进行视觉-语言预训练的局限性，以及因果建模等替代方法的必要性。</p>\n<h2 id=\"教程类型\"><a href=\"#教程类型\" class=\"headerlink\" title=\"教程类型\"></a>教程类型</h2><p>这是一个前沿教程，重点讨论视觉语言预训练的新趋势：是否最新的模型导致更好的表示，以及它们如何有助于下游任务。我们计划主要讨论2018年及之后的最新论文，但也将包括2018年之前在当前视觉语言范式中发挥关键作用的有影响力的论文。</p>\n<h2 id=\"受众\"><a href=\"#受众\" class=\"headerlink\" title=\"受众\"></a>受众</h2><p>我们希望目标受众是对视觉与语言交叉感兴趣的研究者，如语言基础或基础交流研究者。本教程也对初中生谁开始他们的职业生涯感兴趣。熟悉最近的架构(如变压器)是有用的，但不是参加教程所必需的。</p>\n<h1 id=\"Vision-Language-landscape-before-the-Pretraining-Era\"><a href=\"#Vision-Language-landscape-before-the-Pretraining-Era\" class=\"headerlink\" title=\"Vision-Language landscape before the Pretraining Era\"></a>Vision-Language landscape before the Pretraining Era</h1><h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><ul>\n<li>Common VL tasks</li>\n<li>Task specific datasets and models</li>\n<li>What did the community gain?</li>\n<li>Open problems and avenues for future research</li>\n</ul>\n<h2 id=\"Common-VL-tasks\"><a href=\"#Common-VL-tasks\" class=\"headerlink\" title=\"Common VL tasks\"></a>Common VL tasks</h2><p>（1）图像检索</p>\n<p>● High level similarity<br>● Easy evaluation (recall@K)</p>\n<p><img src=\"/2023/01/15/vision-language/image1.PNG\"></p>\n<p>(2) Grounding Referring Expressions</p>\n<p><img src=\"/2023/01/15/vision-language/image2.PNG\"></p>\n<p>● Spatial localization<br>● Finer grained grounding<br>● Easy evaluation (precision@1)</p>\n<p>(3) Image Captioning</p>\n<p>● Language generation (in addition to visual recognition)<br>● Difficult automatic evaluation (BLEU, CIDEr)</p>\n<p><img src=\"/2023/01/15/vision-language/image3.PNG\"></p>\n<p>(4) Visual Question Answering</p>\n<p>● Elicit specific information from images<br>● Relatively easier evaluation (accuracy using string matching)</p>\n<p><img src=\"/2023/01/15/vision-language/image4.PNG\"></p>\n<p>(4 ) Visual Dialog</p>\n<p><img src=\"/2023/01/15/vision-language/image5.PNG\"></p>\n<ul>\n<li>Context modelling in addition to grounding </li>\n<li>Difficult to evaluate free form answers (retrieval metric used)</li>\n</ul>\n<p>Why vision and language?</p>\n<ul>\n<li>Intuitive:<ul>\n<li>Humans learn in multimodal settings</li>\n</ul>\n</li>\n<li>Applications:<ul>\n<li>Aid to visually impaired users</li>\n<li>Online shopping and organizing photos</li>\n<li>Grounded virtual assistants</li>\n</ul>\n</li>\n<li>Scientific:<ul>\n<li>Visual recognition</li>\n<li>Language understanding</li>\n<li>Grounding language into vision</li>\n<li>Compositional reasoning</li>\n<li>Commonsense reasoning</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"任务特定的数据和模型\"><a href=\"#任务特定的数据和模型\" class=\"headerlink\" title=\"任务特定的数据和模型\"></a>任务特定的数据和模型</h2><p>（1）Basic skeleton of most VL models (Image Retrieval)</p>\n<img src=\"/2023/01/15/vision-language/work\\个人博客\\blog\\source\\_posts\\vision-language\\image6.PNG\" style=\"zoom: 67%;\">\n\n<p>(2)Basic skeleton of most VL models (Grounding Referring Expressions)</p>\n<img src=\"/2023/01/15/vision-language/work\\个人博客\\blog\\source\\_posts\\vision-language\\image7.PNG\" style=\"zoom:67%;\">\n\n<p>(3) Basic skeleton of most VL models (VQA)</p>\n<img src=\"/2023/01/15/vision-language/img8.PNG\" style=\"zoom:67%;\">\n\n<p>(4) Basic skeleton of most VL models (Image Captioning)</p>\n<p><img src=\"/2023/01/15/vision-language/img9.PNG\"></p>\n<p>(5) Basic skeleton of most VL models (Visual Dialog)</p>\n<img src=\"/2023/01/15/vision-language/img10.PNG\" style=\"zoom:67%;\">\n\n<h3 id=\"VL-数据集\"><a href=\"#VL-数据集\" class=\"headerlink\" title=\"VL 数据集\"></a>VL 数据集</h3><ul>\n<li><p>Image Retrieval: <a href=\"https://shannon.cs.illinois.edu/DenotationGraph/\">Flickr</a><em>,</em> <a href=\"https://cocodataset.org/#download\">COCO</a></p>\n</li>\n<li><p>Grounding Referring Expression: <a href=\"https://github.com/lichengunc/refer\">RefCOCO</a>，<a href=\"https://ai.stanford.edu/~yukez/visual7w/\">Visual7W</a></p>\n</li>\n<li><p>Image Captioning: <em><a href=\"https://cocodataset.org/#download\">COCO</a></em></p>\n</li>\n<li><p><em>Visual Question Answering:</em> <em><a href=\"https://visualqa.org/\">VQA v1</a>，</em> *<a href=\"https://visualqa.org/\">VQA v2</a>*， <em><a href=\"https://visualgenome.org/\">Visual Genome</a></em>, <em><a href=\"https://cs.stanford.edu/people/dorarad/gqa/index.html\">GQA</a></em></p>\n</li>\n<li><p>Visual Dialog:<em><a href=\"https://visualdialog.org/\">Visual Dialog</a>，</em> <em><a href=\"https://github.com/GuessWhatGame/guesswhat\">GuessWhat?!</a></em></p>\n</li>\n</ul>\n<h3 id=\"任务1：图像描述（Image-Captioning）\"><a href=\"#任务1：图像描述（Image-Captioning）\" class=\"headerlink\" title=\"任务1：图像描述（Image Captioning）\"></a>任务1：图像描述（Image Captioning）</h3><p>Captioning datasets：COCO [Lin et al., 2014]</p>\n<p><img src=\"/2023/01/15/vision-language/img11.PNG\"></p>\n<p>COCO的 全称是Common Objects in COntext，是微软团队提供的一个可以用来进行图像识别的数据集。MS COCO数据集中的图像分为训练、验证和测试集。</p>\n<ul>\n<li>120k训练集+验证集[vs 1k（Pascal）,31k(Flikr)]</li>\n<li>图像包括91类目标，2.5M的标注样例</li>\n<li>图像描述任务的标注benchmark</li>\n</ul>\n<p>评价指标</p>\n<ul>\n<li>自动评估<ul>\n<li>基于n-gram重叠的度量（BLEU, Rouge, METEOR, CIDEr [Chen et al., 2015]）</li>\n<li>基于场景图的度量（SPICE [Anderson et al., 2016]）</li>\n</ul>\n</li>\n<li>人工评估</li>\n</ul>\n<h3 id=\"Neural-Image-Caption-NIC-CVPR-2015\"><a href=\"#Neural-Image-Caption-NIC-CVPR-2015\" class=\"headerlink\" title=\"Neural Image Caption (NIC) (CVPR 2015)\"></a><strong>Neural Image Caption (NIC) (CVPR 2015)</strong></h3><p>论文：<a href=\"https://arxiv.org/abs/1411.4555\">Show and Tell: A Neural Image Caption Generator</a></p>\n<p>NIC，我们的模型，是基于端到端的神经网络，由视觉CNN和语言生成RNN组成。它从输入图像中生成完整的自然语言句子，如下图的例子所示</p>\n<img src=\"/2023/01/15/vision-language/img12.PNG\" style=\"zoom:67%;\">\n\n<p>模型结构：LSTM模型结合CNN图像嵌入器和词嵌入。LSTM单元之间展开的连接显示为蓝色，它们对应循环连接。所有LSTM单元共享相同的参数。</p>\n<img src=\"/2023/01/15/vision-language/img13.PNG\" style=\"zoom:67%;\">\n\n<p>这些是模型产生的标题，你可以看到，它基本上正确地获得了场景的要点，但当涉及到具体的细节时，它可能不是很准确。</p>\n<p><img src=\"/2023/01/15/vision-language/img14.PNG\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://aclanthology.org/2022.acl-tutorials.7.pdf\">Vision-Language Pretraining: Current Trends and the Future</a></p>\n","tags":["NLP","CV"]}]